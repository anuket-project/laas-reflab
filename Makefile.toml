# ========================
# Environment Configuration
# ========================
[env]
POSTGRES_IMAGE = "postgres:15-alpine"
CONTAINER_NAME = "test_db"
DATABASE_NAME = "liblaas"
DATABASE_USER = "postgres"
DATABASE_PASSWORD = "password"
DATABASE_PORT = "5432"
RUST_BACKTRACE = 0

# Development profile (default) - Local database configuration
[env.development]
DATABASE_URL = { value = "postgres://postgres:password@localhost:5432/liblaas", condition = { env_not_set = [
  "DATABASE_URL",
] } }

# CI profile - Expects external database configuration
[env.ci]
DATABASE_URL = { value = "${DATABASE_URL}" }

# ========================
# Task Definitions
# ========================

# == Development Workflow Tasks ==
# Usage: cargo make [task]

# Starts local PostgreSQL container for development
[tasks.setup-db]
condition = { profiles = ["development"] }
workspace = false
script = '''
docker stop ${CONTAINER_NAME} || true
docker rm ${CONTAINER_NAME} || true
docker run --name ${CONTAINER_NAME} \
  -e POSTGRES_USER=${DATABASE_USER} \
  -e POSTGRES_DB=${DATABASE_NAME} \
  -e POSTGRES_PASSWORD=${DATABASE_PASSWORD} \
  -p ${DATABASE_PORT}:5432 \
  -d ${POSTGRES_IMAGE}
'''

# Waits for database to become ready
# Depends on: setup-db
[tasks.wait-db]
workspace = false
condition = { profiles = ["development"] }
script = '''
docker exec ${CONTAINER_NAME} sh -c \
  "while ! pg_isready -U ${DATABASE_USER} -d ${DATABASE_NAME}; do sleep 1; done"
'''

# Applies database migrations
# Depends on: setup-db, wait-db
[tasks.migrate]
workspace = false
install_crate = "sqlx-cli"
command = "cargo"
args = ["sqlx", "migrate", "run"]
dependencies = ["setup-db", "wait-db"]

# Load a new database from a SQL dump file
# Usage: cargo make restore-db --env SQL_DUMP=path/to/dump.sql
[tasks.restore-db]
workspace = false
condition = { profiles = ["development"] }
dependencies = ["setup-db", "wait-db"]
script = [
  '''
  if [ -z "${SQL_DUMP}" ]; then
    echo "Error: SQL_DUMP environment variable not set."
    exit 1
  fi

  echo "Restoring database from ${SQL_DUMP}..."

  docker cp ${SQL_DUMP} ${CONTAINER_NAME}:/tmp/dump.sql
  docker exec -u postgres ${CONTAINER_NAME} sh -c "psql -d ${DATABASE_NAME} -f /tmp/dump.sql"

  echo "Database restore completed."
  ''',
]

# Prepares SQLx offline queries (required before building)
# Depends on: migrate
[tasks.prepare]
workspace = false
install_crate = "sqlx-cli"
command = "cargo"
args = ["sqlx", "prepare", "--workspace"]
dependencies = ["migrate"]

# Runs all tests with local database
# Usage: cargo make test-local
[tasks.test-local]
workspace = false
install_crate = "cargo-nextest"
command = "cargo"
args = ["nextest", "run"]
dependencies = ["prepare"]

# Generates local LCOV coverage report
# Usage: cargo make test-local-coverage
[tasks.test-local-coverage]
workspace = false
args = [
  "llvm-cov",
  "--workspace",
  "--lcov",
  "--output-path",
  ".coverage/lcov.info",
  "nextest",
]
command = "cargo"
dependencies = [
  "prepare",
  "ensure-directories",
  "install-rust-components",
  "install-llvm-cov",
]


# == CI Pipeline Tasks ==
# Usage: cargo make [task] --profile ci

# Run tests and output html code coverage artifact
# # Usage: cargo make test-ci-coverage --profile ci
[tasks.test-ci-coverage]
workspace = false
args = ["llvm-cov", "--workspace", "--html", "nextest", "--profile", "ci"]
command = "cargo"
dependencies = [
  "prepare",
  "ensure-directories",
  "install-rust-components",
  "install-llvm-cov",
]

# Full CI pipeline entry point
# Usage: cargo make ci --profile ci
[tasks.ci]
workspace = false
condition = { profiles = ["ci"] }
script = [
  'cp target/nextest/ci/junit.xml junit.xml',
  'if [ "${CARGO_MAKE_PROFILE}" = "ci" ]; then echo "Cleaning target/ after tests..."; cargo clean; fi',
]
dependencies = ["test-ci-coverage"]

# == Quality Control Tasks (Both Profiles) ==

# Verify code formatting
[tasks.fmt]
workspace = false
script = [
  'cargo fmt --all --check',
  'if [ "${CARGO_MAKE_PROFILE}" = "ci" ]; then echo "Cleaning target/ after fmt..."; cargo clean; fi',
]

# Run strict lint checks
[tasks.clippy]
clear = true
workspace = false
install_crate = "cargo-limit"
env = { SQLX_OFFLINE = "true" }
script = [
  'cargo lclippy --all-targets --all-features -- -D warnings',
  'if [ "${CARGO_MAKE_PROFILE}" = "ci" ]; then echo "Cleaning target/ after clippy..."; cargo clean; fi',
]

# Detect unused dependencies
[tasks.machete]
workspace = false
install_crate = "cargo-machete"
script = [
  # 1) run machete
  'cargo machete',
  # 2) if in CI, clean up afterwards
  'if [ "${CARGO_MAKE_PROFILE}" = "ci" ]; then echo "Cleaning target/ after machete..."; cargo clean; fi',
]


# Full source‐code check
[tasks.check]
clear = true
workspace = false
env = { SQLX_OFFLINE = "true" }
script = [
  'cargo lcheck --all-targets --all-features',
  'if [ "${CARGO_MAKE_PROFILE}" = "ci" ]; then echo "Cleaning target/ after check..."; cargo clean; fi',
]
dependencies = ["install-limit"]

# Full source‐code check
[tasks.audit]
clear = true
workspace = false
install_crate = "cargo-audit"
script = [
  'cargo audit',
  'if [ "${CARGO_MAKE_PROFILE}" = "ci" ]; then echo "Cleaning target/ after check..."; cargo clean; fi',
]


# ========================
# Workflow Presets
# ========================

[tasks.default]
# Default development workflow: local tests + coverage
alias = "test-local-coverage"

[tasks.full-check]
# Comprehensive local check: tests + linting + security
dependencies = ["test-local-coverage", "fmt", "clippy", "audit", "machete"]

# ========================
# Dependency Management
# ========================

# detect Linux distribution
[tasks.detect-distro]
workspace = false
private = true
script = '''
if [ -f /etc/os-release ]; then
  . /etc/os-release
  echo "Detected distro: $ID"
  export DISTRO_ID=$ID
else
  echo "Warning: Cannot detect Linux distribution"
  export DISTRO_ID=unknown
fi
'''

# Install system dependencies based on distro
[tasks.install-system-deps]
workspace = false
script = '''
#!/bin/bash
set -e

echo ""
echo "===================================================================="
echo "System Dependencies Check"
echo "===================================================================="

# Detect distro
if [ -f /etc/os-release ]; then
  . /etc/os-release
  DISTRO_ID=$ID
  DISTRO_NAME="$NAME"
  echo "Detected distribution: $DISTRO_NAME ($DISTRO_ID)"
else
  echo "WARNING: Cannot detect Linux distribution"
  echo "Skipping system dependency checks"
  echo ""
  exit 0
fi

# Function to check if a command exists
command_exists() {
  command -v "$1" >/dev/null 2>&1
}

# Check dependencies
echo ""
echo "Checking required packages:"
MISSING=()
INSTALLED=()

if ! command_exists mold; then
  MISSING+=("mold")
else
  INSTALLED+=("mold")
fi

if ! command_exists clang; then
  MISSING+=("clang")
else
  INSTALLED+=("clang")
fi

if ! command_exists python3-config; then
  MISSING+=("python3-devel")
else
  INSTALLED+=("python3-devel")
fi

# Display status
for pkg in "${INSTALLED[@]}"; do
  echo "  [OK] $pkg"
done

for pkg in "${MISSING[@]}"; do
  echo "  [MISSING] $pkg"
done

if [ ${#MISSING[@]} -eq 0 ]; then
  echo ""
  echo "All system dependencies satisfied"
  echo ""
  exit 0
fi

echo ""
echo "Installing ${#MISSING[@]} missing package(s)..."
echo ""

case "$DISTRO_ID" in
  fedora|rhel|centos|rocky|almalinux)
    PKG_MGR="dnf"
    PKGS=""
    for pkg in "${MISSING[@]}"; do
      case "$pkg" in
        python3-devel) PKGS="$PKGS python3-devel" ;;
        *) PKGS="$PKGS $pkg" ;;
      esac
    done

    echo "Executing: sudo $PKG_MGR install -y$PKGS"
    sudo dnf install -y $PKGS
    ;;

  ubuntu|debian|pop|linuxmint)
    PKG_MGR="apt"
    PKGS=""
    for pkg in "${MISSING[@]}"; do
      case "$pkg" in
        python3-devel) PKGS="$PKGS python3-dev" ;;
        *) PKGS="$PKGS $pkg" ;;
      esac
    done

    echo "Executing: sudo apt-get update && sudo apt-get install -y$PKGS"
    sudo apt-get update -qq
    sudo apt-get install -y $PKGS
    ;;

  arch|manjaro|endeavouros)
    PKG_MGR="pacman"
    PKGS=""
    for pkg in "${MISSING[@]}"; do
      case "$pkg" in
        python3-devel) ;; # Included in python package
        *) PKGS="$PKGS $pkg" ;;
      esac
    done

    if [ -n "$PKGS" ]; then
      echo "Executing: sudo pacman -S --noconfirm$PKGS"
      sudo pacman -S --noconfirm $PKGS
    fi
    ;;

  opensuse*|suse|sles)
    PKG_MGR="zypper"
    PKGS=""
    for pkg in "${MISSING[@]}"; do
      case "$pkg" in
        python3-devel) PKGS="$PKGS python3-devel" ;;
        *) PKGS="$PKGS $pkg" ;;
      esac
    done

    echo "Executing: sudo zypper install -y$PKGS"
    sudo zypper install -y $PKGS
    ;;

  *)
    echo "ERROR: Unsupported distribution: $DISTRO_ID"
    echo ""
    echo "Please manually install: ${MISSING[*]}"
    echo "Then re-run the build"
    echo ""
    exit 1
    ;;
esac

echo ""
echo "System dependencies installed successfully"
echo ""
'''

# Install Rust toolchain components
[tasks.install-rust-components]
workspace = false
script = '''
#!/bin/bash
set -e

echo ""
echo "===================================================================="
echo "Rust Toolchain Components"
echo "===================================================================="

# Check if llvm-tools-preview is installed
if rustup component list | grep -q "llvm-tools-preview (installed)"; then
  echo "[OK] llvm-tools-preview (already installed)"
  echo ""
else
  echo "Installing llvm-tools-preview component..."
  rustup component add llvm-tools-preview
  echo ""
  echo "llvm-tools-preview installed successfully"
  echo ""
fi
'''

# Ensure required directories exist
[tasks.ensure-directories]
workspace = false
script = '''
#!/bin/bash
set -e

echo ""
echo "===================================================================="
echo "Workspace Directory Structure"
echo "===================================================================="

if [ ! -d ".coverage" ]; then
  echo "Creating .coverage/ directory..."
  mkdir -p .coverage
  echo "[OK] .coverage/ created"
else
  echo "[OK] .coverage/ exists"
fi

if [ ! -d "/etc/laas-reflab" ]; then
  echo "Creating /etc/laas-reflab directory..."
  mkdir /etc/laas-reflab
  echo "[OK] /etc/laas-reflab created"
fi

if [ ! -d "/etc/laas-reflab/config.yaml" ]; then
  echo "Creating /etc/laas-reflab/config.yaml file from sample_config.yaml..."
  cp sample_config.yaml /etc/laas-reflab/config.yaml
  echo "[OK] /etc/laas-reflab/config.yaml created"
fi

echo ""
'''

# Master setup task - runs all dependency installations
[tasks.setup-dev-env]
workspace = false
description = "Install all development dependencies (system packages, Rust components, directories)"
dependencies = [
  "install-system-deps",
  "install-rust-components",
  "ensure-directories",
  "install-nextest",
  "install-llvm-cov",
]

# Coverage tool installation
[tasks.install-llvm-cov]
workspace = false
install_crate = "cargo-llvm-cov"

# Test runner installation
[tasks.install-nextest]
workspace = false
install_crate = "cargo-nextest"

# Cargo limit installation
[tasks.install-limit]
workspace = false
install_crate = "cargo-limit"
